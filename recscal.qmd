---
title: "Reciprocal scaling"
params:
  colsite: "burlywood4"
  colspp: "cornflowerblue"
---

```{r, results='hide', message=FALSE}
#| code-fold: true

# Paths
library(here)

# Multivariate analysis
library(ade4)
library(adegraphics)

# dc-CA
source(here("functions/dpcaiv2-ade4.R"))

# Reciprocal scaling
source(here("functions/reciprocal.R"))

# Matrix algebra
library(expm)

# Plots
library(ggplot2)
library(ggrepel)

library(CAnetwork)
library(patchwork)
```

```{r}
#| code-fold: true

# Define bound for comparison to zero
zero <- 10e-10
```

## Introduction

Reciprocal scaling was introduced by @thioulouse1992. It is a technique allowing to compute the coordinates of each row/column cell in the multivariate space, and to plot them in a single space, which then allows to get the conditional mean and variance per row or column.

This technique was initially defined in the frame of correspondence analysis, but it is extended to canonical CA in [reciprocal scaling (CCA)](recscal_cca.qmd) and double-constrained CA in in [reciprocal scaling (dcCA)](recscal_dcca.qmd).

Here, we will analyze matrix $Y$:

```{r, echo = FALSE, message = FALSE}
#| code-fold: true

dat <- readRDS(here("data/Barbaro2012.rds"))
Y <- dat$comm

r <- dim(Y)[1]
c <- dim(Y)[2]

plotmat(r = r, c = c)
```

```{r}
(r <- dim(Y)[1])
(c <- dim(Y)[2])
```

## Computation

::: {.callout-tip title="*TL;DR*"}
Reciprocal scaling gives a score per correspondence (row/column pair) on each ordination axis (instead of a score per row and per column in CA).

These scores can be presented in a matrix $H$ ($n_\bar{0} \times K$). Here, $n_\bar{0}$ is the number of nonzero cells in $Y$, also called correspondences ($n_\bar{0} = \sum_Y y_{ij} \neq 0$) and $K$ is the number of eigenvalues (axes) of the CA. Each row of $H$ corresponds to a row/column pair.

**From CA scores**

$H$ can be computed from the scores of the correspondence analysis of $Y$. The score $h_k(i, j)$ for row $i$, column $j$ and axis $k$ is:

$$
h_k(i, j) = \frac{u^\star_k(i) + v^\star_k(j)}{\sqrt{2 \lambda_k \mu_k}}
$$

where $v^\star_k(j)$ and $u^\star_k(i)$ are the vectors of scores obtained by weighted averaging for CA for axis $k$ (respectively equal to `co` and `li`).


if $y_{ij} = 0$, then the score $h_k(i, j)$ is not defined.

**From canonical correlation analysis**

We transform the table $Y$ in two tables:

-   $R$ ($n_\bar{0} \times r$)
-   $C$ ($n_\bar{0} \times c$)

Each row of $R$ and $C$ contains an indicator vector. The 1 is in the column corresponding to the row (for $R$) or column (for $C$) of the nonzero cell in $Y$.

Additionally, we have a weights vector $w = y_{ij}$ (the same for $R$ and $C$).

Then, we perform a (weighted) canonical correlation analysis of $R_{scaled}$ and $C_{scaled}$. $X_{scaled}$ corresponds to $X$ center and scaled (here, with the weights $w$).

Canonical correlation analysis gives the vectors of canonical coefficients $\rho$ and $\gamma$ (resp. for $R_{scaled}$ and $C_{scaled}$). The scores of the matrices are then $S_R = R_{scaled} \rho$ and $S_C = C_{scaled} \gamma$.

Finally, $H$ is computed as:

$$
H = (S_R + S_C)_{scaled}
$$
:::


### From CA

We perform the CA of table $Y$ ($r \times c$).

```{r}
kca <- min(r - 1, c - 1) # non-null eigenvalues

Ydf <- as.data.frame(Y)
ca <- dudi.coa(Ydf, 
               scannf = FALSE,
               nf = kca)

Ustar <- ca$li
Vstar <- ca$co

lambda <- ca$eig
```

We compute the reciprocal scaling score for comparison:

```{r}
rec_ca <- reciprocal.coa(ca)
```

We can get the coordinates of row-column pairs (ie each cell in the original table $Y$) with:

$$
h_k(i, j) = \frac{u^\star_k(i) + v^\star_k(j)}{\sqrt{2 \lambda_k \mu_k}}
$$

where $u^\star_k(i)$ is the coordinate of row (site) $i$ on axis $k$ and $v^\star_k(j)$ is the same for column (species) $j$ and $\mu_k = 1 + \sqrt{\lambda_k}$.

```{r}
mu <- 1 + sqrt(lambda)
```

Let's compute $H$ from the CA scores with our example dataset.

```{r}
# Transform matrix to count table
Yfreq <- as.data.frame(as.table(Y))
colnames(Yfreq) <- c("row", "col", "Freq")

# Remove the cells with no observation
Yfreq0 <- Yfreq[-which(Yfreq$Freq == 0),]
Yfreq0$colind <- match(Yfreq0$col, colnames(Y)) # match index and species names

# Initialize results matrix
H <- matrix(nrow = nrow(Yfreq0), 
            ncol = length(lambda))

for (k in 1:length(lambda)) { # For each axis
  ind <- 1 # initialize row index
  for (obs in 1:nrow(Yfreq0)) { # For each observation
    i <- Yfreq0$row[obs]
    j <- Yfreq0$col[obs]
    H[ind, k] <- (Ustar[i, k] + Vstar[j, k])/sqrt(2*lambda[k]*mu[k])
    ind <- ind + 1
  }
}
```

The result is a matrix $H$ with $n_\bar{0} = \sum_Y y_{ij} \neq 0$ rows (one row for each nonzero cell in $Y$, called correspondences) and $K$ columns (one column per principal axis of the CA):

```{r, fig.height=10, fig.width=4}
#| code-fold: true
plotmat(r = sum(Y != 0), c = length(lambda),
        Yname = "italic(H)",
        rname = "italic(n[bar(0)])",
        cname = "italic(K)",
        plot.margin.x = 10)
```

We check that the loop did what we want:

```{r}
#| code-fold: true

# Choose one element of H
i <- 1 # row
j <- 3 # column
jtxt <- colnames(Y)[j]
l <- 2 # axis

Htest <- H[Yfreq0$row == i & Yfreq0$col == jtxt, k]

# Compute one value with the formula
Hkij <- (Ustar[i, k] + Vstar[j, k])/sqrt(2*lambda[k]*mu[k])

# Compare
Htest/Hkij
```

Compare the results computed above with the results from `reciprocal.coa` function in ade4:

```{r}
all(H/rec_ca[, 1:kca] - 1 < zero)
```


### From canonical correlation analysis

Canonical correlation analysis is the extension of correlation to multidimensional analysis. This method allows to find the coefficients to maximize the correlation between the columns of two matrices.

First, we compute the inflated tables $R$ ($n_\bar{0} \times r$) and $C$ ($n_\bar{0} \times c$) from $Y$ ($r \times c$).

We take the frequency table defined before and use it to compute the inflated tables (with weights):

```{r}
# Create indicator tables
tabR <- acm.disjonctif(as.data.frame(Yfreq0$row))
colnames(tabR) <- rownames(Y)
tabC <- acm.disjonctif(as.data.frame(Yfreq0$col))
colnames(tabC) <- colnames(Y)

# Get weights
wt <- Yfreq0$Freq
```

Below are the first lines of tables $R$ and $C$ (respectively):

```{r}
#| code-fold: true
knitr::kable(head(tabR, 30))
knitr::kable(head(tabC, 30))
```

Then, we perform a canonical correlation on the scaled tables $R_{scaled}$ and $C_{scaled}$. We find the coefficients $\rho$ and $\gamma$ maximizing the correlation between the scores $S_R = R_{scaled} \rho$ and $S_C = C_{scaled} \gamma$.

```{r}
# Center tables
tabR_scaled <- scalewt(tabR, wt, 
                       scale = FALSE)
tabC_scaled <- scalewt(tabC, wt, 
                       scale = FALSE)

res <- cancor(diag(sqrt(wt)) %*% tabR_scaled, 
              diag(sqrt(wt)) %*% tabC_scaled, 
              xcenter = FALSE, ycenter = FALSE)
# res gives the coefficients of the linear combinations that maximizes the correlation between the 2 dimensions
ncol(res$xcoef) # r-1 columns -> R_scaled is not of full rank
ncol(res$ycoef) # c-1 columns -> C_scaled is not of full rank

# Compute these scores from this coef
scoreR <- tabR_scaled[, 1:(r-1)]  %*% res$xcoef
scoreC <- tabC_scaled[, 1:(c-1)]  %*% res$ycoef
```

Finally, we compute $H = (S_R + S_C)_{scaled}$.

```{r}
# Get H
scoreRC <- scoreR[, 1:(c-1)] + scoreC[, 1:(c-1)] # here c-1 < r so c-1 axes
scoreRC_scaled <- scalewt(scoreRC, wt = wt) # normalisation Ã  1
```

We check the agreement of $H$ defined with CA of with canonical correlation analysis:

```{r}
# Check agreement of RC score and H score defined above
all(abs(scoreRC_scaled/H) - 1 < zero)
```

### Plots

The scores $H$ are displayed below on the first two axes:

```{r, warning=FALSE, fig.height=6, fig.width=6}
#| code-fold: true
multiplot(indiv_row = H, 
          indiv_row_lab = paste0("site ", Yfreq0$row, "/", Yfreq0$col),
          row_color = "black", eig = lambda)
```

We can group those scores by sites:

```{r}
#| code-fold: true

# Group by sites
s.label(H,
        labels = paste(Yfreq0$row, Yfreq0$col, sep = "-"),
        plabels.optim = TRUE,
        plabels.col = "darkgrey",
        main = "Sites")
s.class(H, 
        wt = Yfreq0$Freq,
        fac = as.factor(Yfreq0$row),
        plabels.col = params$colsite,
        add = TRUE)
```

Or by species:

```{r}
#| code-fold: true

# Group by species
s.label(H,
        labels = paste(Yfreq0$row, Yfreq0$col, sep = "-"),
        plabels.optim = TRUE,
        plabels.col = "darkgrey",
        main = "Species")
s.class(H, 
        wt = Yfreq0$Freq,
        fac = as.factor(Yfreq0$colind),
        labels = colnames(Y),
        plabels.col = params$colspp,
        add = TRUE)
```

We will demonstrate more in-depth below how these groups are linked to the CA scores (means and variances can be computed directly from the CA scores.)

## Conditional means and variances of RC scores

::: {.callout-tip title="*TL;DR*"}
Once we have the correspondences scores, we can group them by row (site) or column (species) to compute conditional summary statistics:

-   conditional mean for site $i$ or species $j$ (for each axis $k$)
-   conditional variance for site $i$ or species $j$ (for each axis $k$)
-   conditional covariance for site $i$ or species $j$ (between axes $k$ and $l$)

These conditional statistics can be computed using $h_k(i, j)$ or using the CA scores:

**Formulas using** $h_k(i, j)$

The means are simply the weighted means of the $h_k(i, j)$ for a fixed $i$ or $j$ (corresponds to `meanfacwt`).
Similarly, the variances are weighted variances (can be computed with `varfacwt`).


|                                  | Rows (sites)                                                                               | Columns (species)                                                                           |
|-------------------|------------------------------|------------------------|
| Mean for axis $k$                | $$m_k(i) = \frac{1}{y_{i\cdot}} \sum_{j = 1}^c y_{ij} h_k(i, j)$$                           | $$m_k(j) = \frac{1}{y_{\cdot j}} \sum_{i = 1}^r y_{ij} h_k(i, j)$$                           |
| Variance for axis $k$            | $$s_k^2(i) = \frac{1}{y_{i\cdot}} \sum_{j = 1}^c y_{ij} \left(h_k(i, j) - m_k(i)\right)^2$$ | $$s_k^2(j) = \frac{1}{y_{\cdot j}} \sum_{i = 1}^r y_{ij} \left(h_k(i, j) - m_k(j)\right)^2$$ |
| Covariance between axes $k$, $l$ | $$c_{kl}(i) = \frac{1}{y_{i \cdot}}\sum_{j=1}^c y_{ij}h_k(i, j)h_l(i, j) - m_k(i)m_l(i)$$  | $$c_{kl}(j) = \frac{1}{y_{\cdot j}}\sum_{i=1}^r y_{ij}h_k(i, j)h_l(i, j) - m_k(j)m_l(j)$$   |

**Formulas using CA scores**

Summary statistics are also related to CA scores. 

More precisely, the means by species or site is equivalent to the CA coordinates (`co` and `li`) but with a proportionality a factor $\frac{\sqrt{\mu_k}}{\sqrt{2\lambda_k}}$.

The variances are equivalent to a "weighted variance" (the formula resembles the variance developed formula: $\frac{\sum x_i^2}{n} - \bar{x}^2$).


|                                  | Rows (sites)                                                                                                                                                                                | Columns (species)                                                                                                                                                                           |
|-------------------|------------------------------|------------------------|
| Mean for axis $k$                | $$m_k(i) = \frac{\sqrt{\mu_k}}{\sqrt{2\lambda_k}} u^\star_k(i)$$                                                                                                                                  | $$m_k(j) = \frac{\sqrt{\mu_k}}{\sqrt{2\lambda_k}} v^\star_k(j)$$                                                                                                                                  |
| Variance for axis $k$            | $$s^2_k(i) = \frac{1}{2\lambda_k\mu_k} \left( \frac{1}{y_{i \cdot}} \sum_{j = 1}^c \left(y_{ij} {v^\star_k(j)}^2 \right) - \lambda_k {u^\star_k(i)}^2 \right)$$                                             | $$s^2_k(j) = \frac{1}{2\lambda_k\mu_k} \left( \frac{1}{y_{\cdot j}} \sum_{i = 1}^r \left(y_{ij} {u^\star_k(i)}^2 \right) - \lambda_k {v^\star_k(j)}^2 \right)$$                                             |
| Covariance between axes $k$, $l$ | $$c_{kl}(i) = \frac{1}{2\sqrt{\lambda_k \lambda_l} \sqrt{\mu_k \mu_l}} \left( \frac{1}{y_{i \cdot}} \sum_{j = 1}^c y_{ij} v^\star_k(j) v^\star_l(j) - \sqrt{\lambda_k \lambda_l} u^\star_k(i)u^\star_l(i) \right)$$ | $$c_{kl}(j) = \frac{1}{2\sqrt{\lambda_k \lambda_l} \sqrt{\mu_k \mu_l}} \left( \frac{1}{y_{\cdot j}} \sum_{i = 1}^r y_{ij} u^\star_k(i) u^\star_l(i) - \sqrt{\lambda_k \lambda_l} v^\star_k(j)v^\star_l(j) \right)$$ |

***Note: formulas for the variances $s^2_k(i)$ and $s^2_k(j)$ are different from formula (15) in @thioulouse1992 (no square root at the denominator  $2\lambda_k\mu_k$).***
:::


### Using scores $h_k(i, j)$

#### For rows = sites

We compute the weighted mean of $h_k(i, j)$ per row = site $i$.

$$
m_k(i) = \frac{1}{y_{i\cdot}} \sum_{j = 1}^c y_{ij} h_k(i, j)
$$
We can compute means using a loop:

```{r}
#| code-fold: true
# Get marginal counts
yi_ <- rowSums(Y)
y_j <- colSums(Y)
```

```{r}
#| code-fold: true
# Initialize mean vector
mrows <- matrix(nrow = r, 
                ncol = kca) 

for (i in 1:r) {
  # Get nonzero cells for site i
  rows <- which(Yfreq0$row == i)
  
  # Get scores for site i
  Hi <- H[rows, ]
  
  # Get counts for site i
  yij <- Yfreq0$Freq[rows]
  
  # Fill i-th row with site i mean score along each axis
  # (colSums sums all species j in site i)
  if (is.matrix(Hi)) { # There are several species in site i
    mrows[i, ] <- 1/yi_[i]*colSums(diag(yij) %*% Hi)
  } else { # Only one species in that site
    mrows[i, ] <- 1/yi_[i]*colSums(yij %*% Hi)
  }
}
```

We can also compute the mean using `meanfacwt`:

```{r}
mrows2 <- meanfacwt(H, fac = Yfreq0$row, wt = Yfreq0$Freq)

# Check
res <- mrows2/mrows
all(res - 1 < zero)
```

```{r}
# Check agreement with ade4 method
mrows_ade4 <- meanfacwt(rec_ca[, 1:kca], 
                        fac = rec_ca$Row, 
                        wt = rec_ca$Weight)

all(abs(mrows_ade4/mrows) - 1 < zero)
```

We compute the (weighted) variance of $h_k(i, j)$ per row = site $i$.

$$
s_k^2(i) = \frac{1}{y_{i\cdot}} \sum_{j = 1}^c y_{ij} \left(h_k(i, j) - m_k(i)\right)^2
$$ 

*NB: in the original article [@thioulouse1992] they use the compact variance formula, $s_k^2(i) = \frac{1}{y_{i\cdot}} \sum_{j = 1}^c \left(y_{ij} h_k(i, j)^2\right) - m_k(i)^2$ but I prefer the other formula.*

We can use a loop:

```{r}
#| code-fold: true

# Initialize mean vector
varrows <- matrix(nrow = r, 
                  ncol = kca) 

for (i in 1:r) {
  # Get nonzero cells for site i
  rows <- which(Yfreq0$row == i)
  
  # Get scores for site i
  Hi <- H[rows, ]
  
  # Get counts for site i
  yij <- Yfreq0$Freq[rows]
  
  # Fill i-th row with site i variance along each axis
  varrows[i, ] <- 1/yi_[i]*colSums(diag(yij) %*% sweep(Hi, 2, mrows[i, ], "-")^2)
}
```

We can also use `varfacwt`:

```{r}
varrows2 <- varfacwt(H, 
                     fac = Yfreq0$row, 
                     wt = Yfreq0$Freq)

# Check
res <- varrows2/varrows
all(res - 1 < zero)
```

```{r}
# Check agreement with ade4 method
varrows_ade4 <- varfacwt(rec_ca[, 1:kca], 
                         fac = rec_ca$Row, 
                         wt = rec_ca$Weight)

all(abs(varrows_ade4/varrows) - 1 < zero)
```

```{r}
# We can also plot graphs and get back the variance graphical parameter
varrows_plot <- s.class(rec_ca[,  1:2], 
                        fac = rec_ca$Row,
                        wt = rec_ca$Weight, 
                        plot = FALSE)
varrows_ax1 <- sapply(varrows_plot@stats$covvar, function(x) x[1,1])

all(varrows_ax1/varrows[, 1] - 1 < zero)
```

Finally, we can compute the covariance between scores on the several axes per row = site $i$. The covariance between two axes $l$ and $m$ of the multivariate space for site = row $i$ is defined as:

$$
c_{kl}(i) = \frac{1}{y_{i \cdot}}\sum_{j=1}^c y_{ij}h_k(i, j)h_l(i, j) - m_k(i)m_l(i)
$$

```{r}
k <- 1
l <- 2
```

Below, we compute the covariance between axes $k =$ `r k` and $l =$ `r l`.

```{r}
# Test to compute covariance for site 3 only
i <- 3
rows <- which(Yfreq0$row == i)

covrow1 <- (1/yi_[i])*sum(Yfreq0$Freq[rows] * H[rows, k] * H[rows, l]) - mrows[i, k]*mrows[i, l]
```

```{r}
# Compute covariances for all sites

# Create a df containing intermediate computation and row = site identifier
df <- data.frame(var = Yfreq0$Freq*H[, k]*H[, l], 
                 by = Yfreq0$row)
# Get the sum over the different species for each site
sum_per_site <- aggregate(df$var, list(df$by), sum)$x

# Then vector-compute covariances
covrows_kl <- (1/yi_)*sum_per_site - mrows[, k]*mrows[, l]
```

We check that the loop does what we want:

```{r}
#| code-fold: true

covrows_kl[i]/covrow1
```

We could also obtain the same result with `covfacwt`.

```{r}
covrows <- covfacwt(H, fac = Yfreq0$row, wt = Yfreq0$Freq)
# Output: a list of length fac (here, sites) with the variance covariance matrices for each site

covrows_kl2 <- sapply(covrows, function(c) c[k, l])

res <- covrows_kl/covrows_kl2
all(res - 1 < zero)
```

We can also retrieve results from ade4:

```{r}
# Get results with covfacwt
covrows_ade4 <- covfacwt(rec_ca[, 1:kca], 
                         fac = rec_ca$Row, 
                         wt = rec_ca$Weight)

res <- lapply(seq_along(covrows_ade4), 
              function(i) covrows_ade4[[i]]/covrows[[i]])
reslist <- sapply(res, 
                  function(ri) all(ri - 1 < zero))
all(reslist)
```


```{r}
# Get results from ade4 plot
covrows_plot <- s.class(rec_ca[,  k:l], 
                        fac = rec_ca$Row,
                        wt = rec_ca$Weight, 
                        plot = FALSE)
covrows_kl_plot <- sapply(covrows_plot@stats$covvar, function(x) x[k, l])

# Check
all(covrows_kl_plot/covrows_kl2 - 1 < zero)
```

#### For columns = species

Symetrically, we can compute the means, variances and covariances per columns = species $j$.

$$
m_k(j) = \frac{1}{y_{\cdot j}} \sum_{i = 1}^r y_{ij} h_k(i, j)
$$

```{r}
#| code-fold: true

mcols <- meanfacwt(H, 
                   fac = Yfreq0$col, 
                   wt = Yfreq0$Freq)
mcols_ade4  <- meanfacwt(rec_ca[,1:kca], 
                         fac = Yfreq0$col, 
                         wt = Yfreq0$Freq)
res <- mcols/mcols_ade4
all(res - 1 < zero)
```


$$
s_k^2(j) = \frac{1}{y_{\cdot j}} \sum_{i = 1}^r y_{ij} \left(h_k(i, j) - m_k(j)\right)^2
$$

```{r}
#| code-fold: true
varcols <- varfacwt(H, 
                   fac = Yfreq0$col, 
                   wt = Yfreq0$Freq)
varcols_ade4  <- varfacwt(rec_ca[,1:kca], 
                          fac = Yfreq0$col, 
                          wt = Yfreq0$Freq)
```

To check results, we treat as a special case species 7 and 13 because they appear in one site only:

```{r}
colSums(Y != 0) == 1
sp1 <- c(7, 13)
```

Indeed, for this species the variance is null:

```{r}
varcols[sp1, ]
```

```{r}
res <- varcols[-sp1, ]/varcols_ade4[-sp1, ]
all(res - 1 < zero)
```


$$c_{kl}(j) = \frac{1}{y_{\cdot j}}\sum_{i=1}^r y_{ij}h_k(i, j)h_l(i, j) - m_k(j)m_l(j)$$

```{r}
#| code-fold: true
covcols <- covfacwt(H, 
                   fac = Yfreq0$col, 
                   wt = Yfreq0$Freq)
covcols_ade4  <- covfacwt(rec_ca[,1:kca], 
                          fac = Yfreq0$col, 
                          wt = Yfreq0$Freq)

res <- lapply(seq_along(covcols_ade4), 
              function(i) covcols_ade4[[i]]/covcols[[i]])
reslist <- sapply(res, 
                  function(ri) all(ri - 1 < zero))
all(reslist[-sp1])
```

### Using CA scores

#### For rows = sites

The conditional means and variances of rows scores on axis $k$ for row $i$ can also be computed as:

$$
m_k(i) = \frac{\sqrt{\mu_k}}{\sqrt{2\lambda_k}} u^\star_k(i)
$$

where $u^\star_k(i)$ corresponds to the `li` for site $i$ on axis $k$.

```{r}
mrows_ca <- sweep(ca$li, 2, sqrt(mu)/sqrt(2*lambda), "*")

# Check with ade4 value
all(mrows_ca/mrows_ade4 - 1 < zero)
```

The variance can be computed as:

$$
s^2_k(i) = \frac{1}{2\lambda_k\mu_k} \left( \frac{1}{y_{i \cdot}} \sum_{j = 1}^c \left(y_{ij} {v^\star_k(j)}^2 \right) - \lambda_k {u^\star_k(i)}^2 \right)
$$ 

***Note: this formula is different from formula (15) in @thioulouse1992 (no square root at the denominator $2\lambda_k\mu_k$. Numerical computations suggest this is the correct formula.***

```{r}
varrows_ca <- matrix(nrow = r, 
                     ncol = kca)

for (i in 1:r) {
  # Get CA scores for site i
  Li <- Ustar[i, ]
  
  # Compute the part with the sum on Cj
  # we add all coordinates Cj^2 weighted by the number of observations on site i
  sumCj <- t(Y[i, ]) %*% as.matrix(Vstar)^2

  # Fill i-th row with site i variance along each axis
  varrows_ca[i, ] <- 1/(2*lambda*mu)*((1/yi_[i])*sumCj - lambda*as.numeric(Li)^2)
}
```


```{r}
# Check with ade4 value
all(varrows_ca/varrows_ade4 - 1 < zero)
```

We can also compute the covariance using CA coordinates:

$$
c_{kl}(i) = \frac{1}{2\sqrt{\lambda_k \lambda_l} \sqrt{\mu_k \mu_l}} \left( \frac{1}{y_{i \cdot}} \sum_{j = 1}^c y_{ij} v^\star_k(j) v^\star_l(j) - \sqrt{\lambda_k \lambda_l} u^\star_k(i)u^\star_l(i) \right)
$$

We will use the same values as above for $k$ and $l$: $k =$ `r k` and $l =$ `r l`.

```{r}
# Each site is multiplied by its score (Y*Vstar[, k] by column) and then summed per site
sum_per_site <- rowSums(Y %*% diag(Vstar[, k]) %*% diag(Vstar[, l]))

covrows_ca_kl <- 1/(2*sqrt(lambda[k]*lambda[l])*sqrt(mu[k]*mu[l]))*(1/yi_*sum_per_site - sqrt(lambda[k]*lambda[l])*Ustar[, k]*Ustar[, l])
```

Check that the CA formulas give the same result as the weighted covariance of correspondences:

```{r}
# Check result

all(covrows_ca_kl/covrows_kl2 - 1 < zero)
```

#### For columns = species

Similarly, column statistics can be computed from CA with the following formulas:

$$
m_k(j) = \frac{\sqrt{\mu_k}}{\sqrt{2\lambda_k}} v^\star_k(j)
$$
```{r}
mcols_ca <- sweep(ca$co, 2, sqrt(mu)/sqrt(2*lambda), "*")

# Check
all(mcols_ca/mcols_ade4 - 1 < zero)
```

$$
s^2_k(j) = \frac{1}{2\lambda_k\mu_k} \left( \frac{1}{y_{\cdot j}} \sum_{i = 1}^r \left(y_{ij} {u^\star_k(i)}^2 \right) - \lambda_k {v^\star_k(j)}^2 \right)
$$

```{r}
varcols_ca <- matrix(nrow = c, 
                     ncol = kca)

for (j in 1:c) {
  # Get CA scores for species j
  Cj <- Vstar[j, ]
  
  # Compute the part with the sum on Li
  sumLi <- t(Y[, j]) %*% as.matrix(Ustar)^2

  # Fill i-th row with site i variance along each axis
  varcols_ca[j, ] <- 1/(2*lambda*mu)*((1/y_j[j])*sumLi - lambda*as.numeric(Cj)^2)
}
```

```{r}
# Check
all(varcols_ca[-sp1, ]/varcols_ade4[-sp1, ] - 1 < zero)
```


$$
c_{kl}(j) = \frac{1}{2\sqrt{\lambda_k \lambda_l} \sqrt{\mu_k \mu_l}} \left( \frac{1}{y_{\cdot j}} \sum_{i = 1}^r y_{ij} u^\star_k(i) u^\star_l(i) - \sqrt{\lambda_k \lambda_l} v^\star_k(j)v^\star_l(j) \right)
$$


We use the same values of $k =$ `r k` and $l =$ `r l` as above.

```{r}
# Each spp is multiplied by its score (Y*Ustar[, k] by row) and then summed per spp
sum_per_spp <- colSums(diag(Ustar[, k]) %*% diag(Ustar[, l]) %*% Y)

covcols_kl_ca <- 1/(2*sqrt(lambda[k]*lambda[l])*sqrt(mu[k]*mu[l]))*(1/y_j*sum_per_spp - sqrt(lambda[k]*lambda[l])*Vstar[, k]*Vstar[, l])
```

```{r}
# Check
covcols_kl <- sapply(covcols_ade4,
                     function(x) x[k, l])

all(covcols_kl[-sp1]/covcols_kl_ca[-sp1] - 1 < zero)
```


## Conditional means and variances of R scores and C scores

*Note: in this part, we change the notation (notation previously used in this part) and use $L_k(i)$ for `li` and $L1_k(i)$ for `l1` (and the same with $C_k(j)$ for `co` and $C1_k(j)$ for `c1`).*

::: {.callout-tip title="*TL;DR*"}

We can also compute compute means, variances and covariances with the R score or the C score.

We use the notation $m_k(i)$/$s^2_k(i)$ for the mean/variances of sites (index $i$) computed with the RC scores and $mR_k(i)$/$sR^2_k(i)$ for the mean/variances of sites computed with the R score. For the means computed for species, we use index $j$ and for the means/variances computed with C scores, we use $mC$/$sC^2$.

**Definition**

The definitions are simply the groupwise mean, variance and covariance.

+ using R score

|                       | Rows (sites)                      | Columns (species)        |
|-----------------------|-----------------------------------|--------------------------|
| Mean for axis $k$     | $$mR_k(i) = \frac{1}{y_{i\cdot}} \sum_j y_{ij} ~ \text{scoreR}_k(i, j)$$ | $$mR_k(j) = \frac{1}{y_{\cdot j}} \sum_i y_{ij} ~ \text{scoreR}_k(i, j)$$ |                                      
| Variance for axis $k$ |  $$sR^2_k(i) = \frac{1}{y_{\cdot j}} \sum_j y_{ij} ~ \text{scoreR}(i, j)^2 - mR_k(i)^2$$ | $$sR^2_k(j) = \frac{1}{y_{i \cdot}} \sum_j y_{ij} ~ \text{scoreR}(i, j)^2 - mR_k(j)^2$$ |
| Covariance between axes $k$, $l$ | | |

+ using C score

|                       | Rows (sites)                      | Columns (species)        |
|-----------------------|-----------------------------------|--------------------------|
| Mean for axis $k$     | $$mC_k(i) = \frac{1}{y_{i\cdot}} \sum_j y_{ij} ~ \text{scoreC}_k(i, j)$$ | $$mC_k(j) = \frac{1}{y_{\cdot j}} \sum_i y_{ij} ~ \text{scoreC}_k(i, j)$$ |
| Variance for axis $k$ | $$sC^2_k(i) = \frac{1}{y_{\cdot j}} \sum_j y_{ij} ~ \text{scoreC}(i, j)^2 - mC_k(i)^2$$ | $$sC^2_k(j) = \frac{1}{y_{i \cdot}} \sum_j y_{ij} ~ \text{scoreC}(i, j)^2 - mC_k(j)^2$$ |
| Covariance between axes $k$, $l$ | | |

**Formulas using CA score**

Now we can "prove" that the values defined above can be recomputed from the CA scores too.

+ using R score

|                       | Rows (sites)                        | Columns (species)        |
|-----------------------|-------------------------------------|--------------------------|
| Mean for axis $k$     | $\frac{1}{\sqrt{n}} L1_k(i)$ | $\frac{1}{\sqrt{n}} C_k(j)$ |
| Variance for axis $k$ | None                                | $$\frac{1}{n \lambda_k} \left( \frac{1}{y_{\cdot j}} \sum_{i = 1}^r \left(y_{ij} L_k^2(i) \right) - \lambda_k C_k^2(j) \right)$$ |
| Covariance between axes $k$, $l$ | None                     |                          |


+ using C score

|                       | Rows (sites)                      | Columns (species)        |
|-----------------------|-----------------------------------|--------------------------|
| Mean for axis $k$     | $L_k(i) \times \frac{1}{\sqrt{n}}$ | $C1_k(j) \times \frac{1}{\sqrt{n}}$ |
| Variance for axis $k$ |  $$\frac{1}{n \lambda_k} \left( \frac{1}{y_{i \cdot}} \sum_{j = 1}^c \left(y_{ij} C_k^2(j) \right) - \lambda_k L_k^2(i) \right)$$ | None                   |
| Covariance between axes $k$, $l$ |                         | None                    |



**Relation between RC scores and R score / C score**

Finally, we can relate the quantity computed above (with the definition or with the CA scores) with the means/variances/covariances computed with the RC scores.

+ using R score

|                       | Rows (sites)                      | Columns (species)        |
|-----------------------|-----------------------------------|--------------------------|
| Mean for axis $k$     | $$mR_k(i) = \frac{\sqrt{2}}{\sqrt{\mu_k n}} m_k(i)$$ | $$mR_k(j) = \frac{\sqrt{2 \lambda_k}}{\sqrt{\mu_k n}} m_k(j)$$ |
| Variance for axis $k$ | None | $$sR^2_k(j) = \frac{2 \mu_k}{n} s^2_k(j)$$ |
| Covariance between axes $k$, $l$ |  | |

+ using C score

|                       | Rows (sites)                      | Columns (species)        |
|-----------------------|-----------------------------------|--------------------------|
| Mean for axis $k$     | $$mC_k(i) =  \frac{\sqrt{2 \lambda_k}}{\sqrt{\mu_k n}} m_k(i)$$ | $$mC_k(j) = \frac{\sqrt{2}}{\sqrt{\mu_k n}} m_k(j) $$ |
| Variance for axis $k$ | $$sC^2_k(i) = \frac{2 \mu_k}{n} s^2_k(i)$$ | None |
| Covariance between axes $k$, $l$ |  | |

:::

This is not at all developed in the article of @thioulouse1992, but we could also use directly the R scores and the C scores to compute the groupwise (species- or sites-wise) mean and variances. In fact, the means and variances computed from the scoresR and scoresC should be related to the means and variances computed from $L_k(i)$ = `li` and $C_k(j)$ = `co`, since scoreR = `l1` and scoreC = `c1`.

We bother computing these because with CCA and dc-CA, we can't use directly RC scores. 

### For rows = sites (group per row)

```{r}
n <- sum(Y)
```

#### scoreC

##### Mean

We compute the mean score per site from the **column** scores.

```{r}
mrowsC <- meanfacwt(scoreC, fac = Yfreq0$row, wt = Yfreq0$Freq)
```

We have $mC_k(i) = \frac{L_k(i)}{\sqrt{n}}$.

```{r}
res <- mrowsC/(ca$li * 1/sqrt(n))
all(res - 1 < zero)
```

We can prove that equality: we begin by writing the weighted mean formula of scoreC:

$$mC_k(i) = \frac{1}{y_{i\cdot}} \sum_i y_{ij} ~ \text{scoreC}_k(i, j)$$
We replace scoreC with $\frac{C1_k(j)}{\sqrt{n}}$ (this equality remains to be proven):

$$mC_k(i) = \frac{1}{y_{i\cdot}} \sum_i y_{ij} \frac{C1_k(j)}{\sqrt{n}}$$

Then we remove $\frac{1}{n}$ from the sum:

$$mC_k(i) = \frac{1}{\sqrt{n}}\frac{1}{y_{i\cdot}} \sum_i y_{ij} C1_k(j)$$
By definition, the `li` are at the mean of the `c1` so we can replace $\frac{1}{y_{i\cdot}} \sum_i y_{ij} C1_k(j)$ with $L_k(i)$:

$$mC_k(i)  = \frac{1}{\sqrt{n}} L_k(i)$$

##### Variance
Now, we compare variances computed with the scoreC and variances computed with the scoreRC.

```{r}
varrowsC <- varfacwt(scoreC, fac = Yfreq0$row, wt = Yfreq0$Freq)
```


We have $sC_k^2(i) = \frac{2\mu_k}{n} ~ s^2_k(i)$.

```{r}
res <- varrowsC / (varrows %*% diag(2*mu) / n)
all(res - 1 < zero)
```


Here too, we can prove the relationship above between the variance of the RC score and the variance of the C score.

$$
\begin{align}
sC_k^2(i) 
&= \frac{1}{y_{\cdot j}} \sum_j y_{ij} ~ \text{scoreC}(i, j)^2 - mC_k(i)^2\\ 
&= \frac{1}{y_{\cdot j}} \sum_j y_{ij} ~ \left(\frac{C1_k(j)}{\sqrt{n}}\right)^2 - \left(\frac{L_k(i)}{\sqrt{n}}\right)^2\\ 
&= \frac{1}{n} \left(\frac{1}{y_{\cdot j}} \sum_j y_{ij} ~ C1_k(j)^2 - L_k(i)^2\right)\\ 
&= \frac{1}{n} \left(\frac{1}{y_{\cdot j}} \sum_j y_{ij} ~ \left( \frac{C_k(j)}{\sqrt{\lambda_k}}\right)^2 - L_k(i)^2\right)\\ 
&= \frac{1}{n} \times \frac{1}{\lambda_k} \left(\frac{1}{y_{\cdot j}} \sum_j y_{ij} ~ C_k(j)^2 - \lambda_k L_k(i)^2\right)\\ 
&= \frac{1}{n} \times \frac{1}{\lambda_k} \times 2\lambda_k \mu_k \times \frac{1}{2\lambda_k \mu_k} \left(\frac{1}{y_{\cdot j}} \sum_j y_{ij} ~ C_k(j)^2 - \lambda_k L_k(i)^2\right)\\ 
sC_k^2(i) &= \frac{2\mu_k}{n} ~ s^2_k(i)
\end{align}
$$

#### scoreR

##### Mean (unique)

We compute the mean score per site from the **sites** scores (i.e. the unique scoreR, since all R values are superimposed for the same site).

```{r}
mrowsR <- meanfacwt(scoreR, fac = Yfreq0$row, wt = Yfreq0$Freq)
```

```{r}
# The mean per site (row) of scoreR is the same as the unique scores
mrowsR_u <- unique(scoreR)
all(mrowsR/mrowsR_u - 1 < zero)
```

```{r}
# NB: weighting doesn't make a difference because all weights are the same for the same row
mrowsR_nw <- meanfacwt(scoreR, fac = Yfreq0$row)

all(mrowsR/mrowsR_nw - 1 < zero)
```

We have $mR_k(i) = \frac{L1_k(i)}{\sqrt{n}}$.

```{r}
res <- mrowsR * sqrt(n)/ca$l1
all(res - 1 < zero)
```

##### Variances (null)
We don't compute variances per rows for the scoreR, because they are null.

#### Plots

Below are R and C scores grouped by sites (rows):

```{r}
s.class(scoreC,
        wt = Yfreq0$Freq,
        fac = as.factor(Yfreq0$row),
        ppoints.col = params$colspp,
        plabels.col = params$colsite, 
        main = "C scores grouped by sitse (rows)")
```

```{r}
s.class(scoreR,
        wt = Yfreq0$Freq,
        fac = as.factor(Yfreq0$row),
        ppoints.col = params$colsite,
        plabels.col = params$colsite, 
        main = "R scores grouped by sites (rows)")
```

We can compare these plots to the RC scores plot below (grouped by sites/rows):

```{r}
s.class(scoreRC_scaled, 
        wt = Yfreq0$Freq,
        fac = Yfreq0$row,
        labels = rownames(Y),
        plabels.col = params$colsite,
        main = "RC scores grouped by sites (rows)")
```

### For columns = species (group per column)

#### scoreC

##### Mean (unique)

We compute the mean score per species from the **column** scores.

```{r}
mcolsC <- meanfacwt(scoreC, fac = Yfreq0$colind, wt = Yfreq0$Freq)
```

We have $mC_k(j) = \frac{C1_k(j)}{\sqrt{n}}$.

```{r}
# Check
res <- mcolsC * sqrt(n)/ca$c1
all(res - 1 < zero)
```

##### Variances (null)

We don't compute variances (they are null).

#### scoreR

##### Mean

We compute the mean score per species from the **row** scores.

```{r}
mcolsR <- meanfacwt(scoreR, fac = Yfreq0$colind, wt = Yfreq0$Freq)
```

We have $mR_k(j) = \frac{C_k(j)}{\sqrt{n}}$.

```{r}
res <- mcolsR/(ca$co/sqrt(n))
all(res - 1 < zero)
```

##### Variances

We compute the variance of species (columns) from the R score:

```{r}
varcolsR <- varfacwt(scoreR, fac = Yfreq0$colind, wt = Yfreq0$Freq)
```

We have $sR_k^2(j) = \frac{2\mu_k}{n} ~ s^2_k(j)$.

```{r}
# Check
res <- (varcolsR[-sp1, 1:kca] %*% diag(1/(2*mu)) * n)/varcols[-sp1, ]
all(res - 1 < zero)
```


**Conclusion: using RC scores or using R scores only to compute species-wise means and variances is the same, but there are some multiplying factors.**

#### Plots

Below are R and C scores grouped by species (columns):

```{r}
s.class(scoreC,
        wt = Yfreq0$Freq,
        fac = as.factor(Yfreq0$colind),
        lab = colnames(Y),
        ppoints.col = params$colspp,
        plabels.col = params$colspp, 
        main = "C scores grouped by species (columns)")
```

```{r}
s.class(scoreR,
        wt = Yfreq0$Freq,
        fac = as.factor(Yfreq0$colind),
        lab = colnames(Y),
        ppoints.col = params$colsite,
        plabels.col = params$colspp, 
        main = "R scores grouped by species (columns)")
```

We can compare these plots to the RC scores plot below (grouped by species/columns):

```{r}
s.class(scoreRC_scaled, 
               wt = Yfreq0$Freq,
               fac = as.factor(Yfreq0$colind),
               labels = colnames(Y),
               plabels.col = params$colspp,
               main = "RC scores grouped by species (columns)")
```

::: {.callout-note}
We can also compare means/variances extracted from the plots:

```{r}
#| code-fold: true
# Plot with RC score = H
xax <- 2
yax <- 3
sRC <- s.class(scoreRC_scaled, 
               xax = xax, yax = yax,
               wt = Yfreq0$Freq,
               fac = as.factor(Yfreq0$colind),
               plot = FALSE)

# Plot with R score
sR <- s.class(scoreR,
              xax = xax, yax = yax,
              wt = Yfreq0$Freq,
              fac = as.factor(Yfreq0$colind),
              plot = FALSE)

# Compare means
fac <- sqrt(mu)/sqrt(2*lambda)
res <- sRC@stats$means/(sR@stats$means %*% diag(fac[c(xax, yax)])*sqrt(n)) 
all(res - 1 < zero) # means are the same

# Compare variances
varRC_ax1 <- (sapply(sRC@stats$covvar, function(x) x[1, 1])*(2*mu[xax]/n))
varR_ax1 <- sapply(sR@stats$covvar, function(x) x[1, 1])

res <- varRC_ax1[-sp1]/varR_ax1[-sp1]
all(res - 1 < zero) # Same on ax1

varRC_ax2 <- (sapply(sRC@stats$covvar, function(x) x[2, 2])*(2*mu[yax]/n))
varR_ax2 <- sapply(sR@stats$covvar, function(x) x[2, 2])

res <- varRC_ax2[-sp1]/varR_ax2[-sp1]
all(res - 1 < zero) # Same on ax2
```
:::

## ggplotting

#### 1d plots


```{r}
#| code-fold: true

# Define plotting function
plot_meanvar <- function(mean, var, groupnames, x = 1, col = "black")  {
  ggplot() +
  geom_point(aes(x = mean[, x], 
                 y = reorder(groupnames, -mean[, x])),
             colour = col, shape = 1) +
  geom_linerange(aes(x = mean[, x], 
                     y = reorder(groupnames, -mean[, x]),
                     xmin = mean[, x] - var[, x],
                     xmax = mean[, x] + var[, x]),
                 colour = col) +
  xlab(paste("Axis", x)) +
  theme_linedraw() +
  theme(axis.title.y = element_blank())
}
```

Let's plot these means and variances along the first axis for rows and columns:


```{r, fig.width=9, fig.height=4}
#| code-fold: true
gr <- plot_meanvar(mean = mrows, 
                   var = 3*sqrt(varrows), 
                   groupnames = rownames(Y),
                   col = params$colsite) +
  ggtitle("Rows (sites) mean and variance")
gc <- plot_meanvar(mean = mcols, 
                   var = 3*sqrt(varcols), groupnames = colnames(Y),
                   col = params$colspp) +
  ggtitle("Columns (species) mean and variance")

gr + gc
```

Same result with ade4 function:

```{r}
#| code-fold: true
s1d.distri(score = ca$li[, 1], 
           dfdistri = as.data.frame(Y),
           ppoints.col = params$colspp,
           plabels.col = params$colspp)

s1d.distri(score = ca$co[, 1], 
           dfdistri = as.data.frame(t(Y)),
           ppoints.col = params$colsite,
           plabels.col = params$colsite)
```

```{r, fig.width=9, fig.height=4}
#| code-fold: true
gr <- ggplot() +
  geom_point(aes(x = covrows_kl2, y = reorder(rownames(Y), -covrows_kl2)),
             col = params$colsite) +
  xlab(paste("Covariances between axes", k, "and", l)) +
  theme_linedraw() +
  theme(axis.title.y = element_blank()) + 
  ggtitle("Rows (sites) covariances")

gc <- ggplot() +
  geom_point(aes(x = covcols_kl, y = reorder(colnames(Y), -covcols_kl)),
             col = params$colspp) +
  xlab(paste("Covariances between axes", k, "and", l)) +
  theme_linedraw() +
  theme(axis.title.y = element_blank()) + 
  ggtitle("Columns (species) covariances")

gr + gc
```

#### 2d plots

We can also plot the ellipses in 2 dimensions.

For that, we need to plot the ellipse summarizing the Gaussian bivariate law for each group. For example, for site $i$ on axes $k$ and $l$ [reference blog post](https://www.xarg.org/2018/04/how-to-plot-a-covariance-error-ellipse/):

-   the mean vector is $\mu(i) = (m_k(i), m_l(i))$
-   the variance-covariance matrix is $\Sigma(i) = \begin{pmatrix} \sigma_k^2 ~ \sigma_{kl}\\ \sigma_{kl} ~ \sigma_{l}^2 \end{pmatrix}$

The simplest equation (covariance zero, centered on the origin) is:

$$\left( \frac{x}{\sigma_k} \right)^2 + \left( \frac{y}{\sigma_l} \right)^2 = s$$ The semi-axes are of length $\sigma_k \sqrt{s}$ and $\sigma_l \sqrt{s}$. $s$ is the scaling factor allowing the ellipsis to encompass all data with a level of confidence $p$. We have $s = -2 \ln(1-p)$.

We can show that this equation is equivalent to

$$\begin{cases} x = \sigma_k \sqrt{s} \cos(t)\\ y = \sigma_l \sqrt{s} \sin(t)  \end{cases}$$ With $t$ being an angle between 0 and $2\pi$.

We write $a$ the length of the semi-major axis and $b$ the length of the semi-minor axis.

Now in case the values $h_k(i, j)$ and $h_l(i, j)$ are correlated, the covariance is not zero. Then, the semi-axes lengths are the square root of the eigenvaluesof $\Sigma(i)$. Geometrically, we have an angle $\theta$ between axis $k$ and the semi-major axis. $\theta$ can be computed as the direction of the first eigenvector $v_1$: $\theta = \arctan(v_1(2)/v_1(1))$.

The equation of the ellipsis is: $$\begin{cases} x = m_k(i) +  a  \cos(\theta) \cos(t) - b \sin(\theta) \sin(t) \\ y = m_l(i) + a \sin(\theta) \cos(t) + b \cos(\theta) \sin(t) \end{cases}$$ With $a = \sqrt{\lambda_1} \sqrt{s}$ and $b = \sqrt{\lambda_2} \sqrt{s}$. (Here we assumed the origin could be different from zero and shifted the center with $m_k(i)$ and $m_l(i)$.)

```{r}
#| code-fold: true
gaussian_ellipses <- function(vars, covars, means, x = 1, y = 2,
                              t = seq(0, 2*pi, 0.01), s = 1.5, ind = 1:nrow(vars)) {
  # Length of angles
  nt <- length(t)
  
  # Initialize matrix
  ellipses_mat <- matrix(nrow = length(t)*nrow(vars), 
                         ncol = 3)
  
  for (i in ind) {
    # Define variance covariance matrix
    covar <- covars[i]
    varx <- vars[i, x]
    vary <- vars[i, y]
    mat <- matrix(data = c(varx, covar,
                           covar, vary),
                  nrow = 2)
    
    # Eigenvalues
    vp <- eigen(mat)$values
    
    a <- s*sqrt(max(vp)) # semi major axis
    b <- s*sqrt(min(vp)) # semi minor axis
    
    # angle (inclination of ellipse from axe x)
    if(covar == 0 & varx >= vary){ # covariance is zero and varx is big
      theta <- 0
    }else if(covar == 0 & varx < vary){ # covariance is zero and varx is small
      theta <- pi/2
    }else{ # "normal" cases
      # get eigenvector associated to largest eigenvalue
      v1 <- eigen(mat)$vectors[,1]
      # theta is the angle of the eigenvector with x -> ie
      # arctan of the slope given by the first eigenvector
      theta <- atan(v1[2]/v1[1])
    }
    
    # x and y coordinates of ellipse
    xellipse <- means[i, x] + a*cos(theta)*cos(t) - b*sin(theta)*sin(t)
    yellipse <- means[i, y] + a*sin(theta)*cos(t) + b*cos(theta)*sin(t)
    
    indmin <- (i-1)*nt + 1
    indmax <- i*nt
    ellipses_mat[indmin:indmax, ] <- matrix(c(xellipse, yellipse, rep(i,nt)),
                                           ncol = 3)
  }
  res <- as.data.frame(ellipses_mat)
  colnames(res) <- c("xell", "yell", "group")
  return(res)
}
```

```{r}
#| code-fold: true

plot_ellipses <- function(var, covar, mean, groupnames, 
                          H, Yfreq0, col = "black", ellipses = 1:nrow(var), s = 1.5, x = 1, y = 2) {
  
  if (all(groupnames %in% Yfreq0$row)) {
    indivtype <- "row"
  } else {
    indivtype <- "colind"
  }
  
  rows <- which(Yfreq0[[indivtype]] %in% ellipses)
  
  # Get gaussian ellipses for the required groups
  ell <- gaussian_ellipses(var, covar, mean, s = s, x = k, y = l, ind = ellipses)
  
  # Plot ellipses from variance and covariance
  ggplot() +
    geom_hline(yintercept = 0) +
    geom_vline(xintercept = 0) +
    geom_point(aes(x = H[, x], y = H[, y], alpha = Yfreq0[[indivtype]] %in% ellipses),
               col = col,
               show.legend = FALSE) +
    scale_alpha_manual(values = c("TRUE" = 1, "FALSE" = 0.2)) +
    # Label ellipse points only
    geom_text_repel(aes(x = H[rows, x], y = H[rows, y], 
                        label = paste(Yfreq0$row[rows], Yfreq0$col[rows])),
                    col = col) +
    geom_polygon(data = ell, 
                 aes(x = xell, y = yell, group = group),
                 fill = col, col = col, alpha = 0.5) +
    theme_linedraw() +
    geom_label(aes(x = mean[, x], y = mean[, y], label = groupnames),
               colour = col) +
    xlab(paste("Axis", x)) +
    ylab(paste("Axis", y)) 
}
```

```{r, fig.width=8, fig.height=4}
#| code-fold: true

gr <- plot_ellipses(varrows, covrows_kl2, mrows, 
                    groupnames = rownames(Y), H = H, Yfreq0 = Yfreq0,
                    col = params$colsite) + ggtitle("Rows (sites)")

gc <- plot_ellipses(varcols, covcols_kl, mcols, 
                    groupnames = colnames(Y), H = H, Yfreq0 = Yfreq0, 
                    col = params$colspp) + ggtitle("Columns (species)")

gr + gc
```

```{r, fig.width=8, fig.height=4}
#| code-fold: true

# Choose a subset of sites
i <- c(2, 13, 18)
gr <- plot_ellipses(varrows, covrows_kl2, mrows, 
                    groupnames = rownames(Y), H = H, Yfreq0 = Yfreq0,
                    ellipses = i, col = params$colsite) + 
  ggtitle("Rows (sites)")

# Choose a subset of species
j <- c(16, 12, 20) # sp21 is index 20
gc <- plot_ellipses(varcols, covcols_kl, mcols, 
                    groupnames = colnames(Y), H = H, Yfreq0 = Yfreq0, 
                    ellipses = j, col = params$colspp) + 
  ggtitle("Columns (species)")

gr + gc
```

Reproduce the same plots with ade4:

```{r}
#| code-fold: true
s.class(rec_ca[, 1:2],
        wt = rec_ca$Weight, 
        fac = rec_ca$Row,
        col = params$colsite,
        main = "Rows (sites)")
s.class(rec_ca[, 1:2], 
        wt = rec_ca$Weight, 
        fac = rec_ca$Col,
        col = params$colspp,
        main = "Columns (species)")
```

## Additional developments

### Formula (3) in @thioulouse1992

Let's test formula (3) in @thioulouse1992:

$$L_k(i) = \sum_{j=1}^c p_{j|i} C_k(j)$$

with $p_{j|i} = \frac{y_{ij}}{y_{i \cdot}}$. This formula relates species and samples scores in CA.

```{r}
# Test formula for a given k
k <- 2

# compute pj|i
pjcondi <- sweep(Y, 1, yi_, "/")

# Compute the formula that should be equal th Lk(i)
res <- vector(mode="numeric", length=nrow(Y))
for (i in 1:nrow(Y)) {
  res[i] <- sum(pjcondi[i, ]*ca$co[, k])
}
```


```{r}
res/ca$li[, k] # not equal
```

We find that in fact the correct formula is

$$L_k(i) = \frac{1}{\sqrt{\lambda_k}}\sum_{j=1}^c p_{j|i} C_k(j)$$

```{r}
res/sqrt(lambda[k])/ca$li[, k]
```

With this equality, we can indeed prove numerically the equivalence between mean computation using $h_k(i, j)$ (Equations (12) and (14) in @thioulouse1992) and using CA coordinates (computation in notebook not shown here).

### Mean of means

The reciprocal scaling mean computed with $\frac{\sqrt{\mu_k}}{\sqrt{2 \lambda_k}} v^\star_k(i)$ is the same as the weighted mean of the weighted means $\frac{\sqrt{\mu_k}}{\sqrt{2 \lambda_k}} u^\star_k(j)$, where $j$ is used to index all species occurring in site $i$. So we can interpret species/site-wise means of the $H$ scores as means of means of the other category.

```{r}
i <- 1 # site
k <- 1:2 # axes

# Get the correspondences for site i
Hsub <- H[Yfreq0$row == i, k]
j <- Yfreq0$col[Yfreq0$row == i]
rownames(Hsub) <- paste0("s", i, "-", j)

# Get the weights of correspondences
wth <- Yfreq0$Freq[Yfreq0$row == i]

# Weighted mean of correspondences
h_i <- meanfacwt(Hsub, wt = wth) 
h_i <- data.frame(t(h_i))
rownames(h_i) <- paste("rec", i)

# Get reciprocal scaling means computed from CA coordinates
# For site i
ca_i <- ca$li[i, k]*sqrt(mu[k])/sqrt(2*lambda[k]) 
rownames(ca_i) <- paste("CA", i)

# For species j present in site i (transformed coordinates)
ca_j <- sweep(ca$co[j, k], 2, sqrt(mu[k])/sqrt(2*lambda[k]), "*")
```

```{r}
# Compare weighted means
h_i/ca_i
```

On this plot, we plot the CA coordinates for site $i$ and for all species $j$ in site $i$ (scaled with a factor $\frac{\sqrt{\mu_k}}{\sqrt{2\lambda_k}}$. We surimpose the reciprocal scaling correspondences for site $i$ (purple dots). 

*NB: Means should be surimposed, I don't know why they are not.*

```{r}
#| code-fold: true
# Plot correspondences and mean
s.class(Hsub, 
        fac = factor(rep(paste("rec", i), nrow(Hsub))),
        wt = wth,
        ppoints.col = "darkgrey",
        main = "Correspondences")
s.label(Hsub, 
        plabels.optim = TRUE, add = TRUE,
        ppoints.col = "darkorchid",
        plabels.col = "darkorchid")
s.label(ca_i, 
        plabels.col = params$colsite, add = TRUE)
s.label(h_i, 
        plabels.col = params$colsite, add = TRUE)
```

```{r}
#| code-fold: true

# Plot CA and mean
# On a separate plot because else ade4 goes crazy
s.class(ca_j,
        ppoints.col = "grey",
        fac = factor(rep(i, nrow(ca_j))),
        wt = wth,
        main = "Means")
s.label(ca_j, 
        plabels.optim = TRUE, add = TRUE,
        plabels.col = params$colspp, 
        ppoints.col = params$colspp, )
s.label(ca_i, 
        plabels.col = params$colsite, add = TRUE)
s.label(h_i, 
        plabels.col = params$colsite, add = TRUE)
```


### Non-reciprocal score

If we don't want to find a new common space to plot correspondences in, we can remain in the 2 biplots showing $V$ with $U^\star$ (`c1` and `li`) (scaling type 1 = rows niches) and $U$ and $V^\star$ (`co` and `l1`) (scaling type 2 = columns niches).


#### H1 for rows niches

To do that, we define the "CA-correspondences" $h1_k(i, j)$ for scaling type 1:

$$h1_k(i, j) = \frac{u^\star_k(i) + v_k(j)}{2}$$
```{r}
# Initialize results matrix
H1 <- matrix(nrow = nrow(Yfreq0), 
             ncol = length(lambda))

for (k in 1:length(lambda)) { # For each axis
  ind <- 1 # initialize row index
  for (obs in 1:nrow(Yfreq0)) { # For each observation
    i <- Yfreq0$row[obs]
    j <- Yfreq0$col[obs]
    H1[ind, k] <- (ca$li[i, k] + ca$c1[j, k])/2
    ind <- ind + 1
  }
}

corresp <- paste(Yfreq0$row, Yfreq0$col, sep = "-")
multiplot(indiv_row = as.data.frame(H1), 
          indiv_row_lab = corresp,
          row_color = "black")
```

```{r}
# Groupwise mean
mrows_nr <- meanfacwt(H1, fac = Yfreq0$row, wt = Yfreq0$Freq)
all(abs(abs(mrows_nr/ca$li) - 1) < zero)
res <- mrows_nr %*% diag(sqrt(mu)/sqrt(2*lambda)) # factor sqrt(mu)/sqrt(2*lambda)
all(abs(res/mrows - 1) < zero) 

# Groupwise variance
varrows_nr <- varfacwt(H1, fac = Yfreq0$row, wt = Yfreq0$Freq)
res <- varrows_nr %*% diag(2/mu) # Factor 2/mu
all(abs(res/varrows) - 1 < zero)

# We could also multiply H1 before computing the variance
H1_scaled <- H1 %*% diag(sqrt(2/mu)) # Factor sqrt(2/mu)
varrows_nr_scaled <- varfacwt(H1_scaled, fac = Yfreq0$row, wt = Yfreq0$Freq)
all(abs(varrows_nr_scaled/varrows - 1) < zero)

# Plots
s.class(H1, fac = Yfreq0$row, main = "Non-reciprocal scaling")
s.class(H, fac = Yfreq0$row, main = "Reciprocal scaling")
```


$h1_k(i, j)$ can also be defined from the canonical correlation scores:

$$h1_k(i, j) = \frac{\sqrt{n} (S_R \Lambda^{1/2} + S_C)}{2}$$
```{r}
# Find back the formula from the scores 
H1_cancor <- (sqrt(n)*(scoreR[, 1:(c-1)] %*% diag(lambda^(1/2)) + scoreC))/2
# H1_cancor_scaled <- scalewt(H1_cancor, wt = wt/sum(wt))

all(abs(abs(H1_cancor/H1) - 1) < zero)
```

#### H2 for columns niches

We define the "CA-correspondences" $h2_k(i, j)$ for scaling type 2:

$$h2_k(i, j) = \frac{u_k(i) + v^\star_k(j)}{2}$$

```{r}
# Initialize results matrix
H2 <- matrix(nrow = nrow(Yfreq0), 
             ncol = length(lambda))

for (k in 1:length(lambda)) { # For each axis
  ind <- 1 # initialize row index
  for (obs in 1:nrow(Yfreq0)) { # For each observation
    i <- Yfreq0$row[obs]
    j <- Yfreq0$col[obs]
    H2[ind, k] <- (ca$l1[i, k] + ca$co[j, k])/2
    ind <- ind + 1
  }
}

corresp <- paste(Yfreq0$row, Yfreq0$col, sep = "-")
multiplot(indiv_row = as.data.frame(H2), 
          indiv_row_lab = corresp,
          row_color = "black")
```

```{r}
# Groupwise mean
mcols_nr <- meanfacwt(H2, fac = Yfreq0$col, wt = Yfreq0$Freq)
all(abs(abs(mcols_nr/ca$co) - 1) < zero) # equal to the co

res <- mcols_nr %*% diag(sqrt(mu)/sqrt(2*lambda)) 
all(abs(res/mcols - 1) < zero) # same as reciprocal scaling by a factor sqrt(mu)/sqrt(2*lambda)

# Groupwise variance
varcols_nr <- varfacwt(H2, fac = Yfreq0$col, wt = Yfreq0$Freq)
varcols_nr_scaled <- varcols_nr %*% diag(2/(mu)) # factor 2/mu
all(abs(varcols_nr_scaled[-sp1, ]/varcols[-sp1, ] - 1) < zero) # same as reciprocal scaling by a factor 2/mu

# Plots
s.class(H2, fac = Yfreq0$row, main = "Non-reciprocal scaling")
s.class(H, fac = Yfreq0$row, main = "Reciprocal scaling")
```


$h2_k(i, j)$ can also be defined from the canonical correlation scores:

$$h2_k(i, j) = \frac{\sqrt{n} (S_R + S_C  \Lambda^{1/2})}{2}$$

```{r}
# Find back the formula from the scores 
H2_cancor <- (sqrt(n)*(scoreR[, 1:(c-1)] + scoreC %*% diag(lambda^(1/2))))/2

all(abs(abs(H2_cancor/H2) - 1) < zero)
```



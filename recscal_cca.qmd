---
title: "Reciprocal scaling with CCA"
editor: visual
params:
  colsite: "burlywood4"
  colspp: "cornflowerblue"
---

```{r, results='hide', message=FALSE}
#| code-fold: true

# Paths
library(here)

# Multivariate analysis
library(ade4)
library(adegraphics)

# dc-CA
source(here("functions/dpcaiv2-ade4.R"))

# Reciprocal scaling
source(here("functions/reciprocal.R"))

# Matrix algebra
library(expm)

# Plots
source(here("functions/plot.R"))
library(gridExtra)
```

## Introduction

This is an extension of reciprocal scaling defined for correspondence analysis by @thioulouse1992 to canonical correspondence analysis.

Here, we start from two matrices:

-   A data matrix $Y$ ($r \times c$)
-   A matrix of predictor variables (environmental variabnes) $E$ ($r \times l$)

```{r, echo=FALSE}
dat <- readRDS(here("data/Barbaro2012.rds"))

Y <- dat$comm
E <- dat$envir

l <- ncol(E)
r <- dim(Y)[1]
c <- dim(Y)[2]

plotmat(r = r, c = c, l = l, 
        E = TRUE)
```

```{r}
(r <- dim(Y)[1])
(c <- dim(Y)[2])
(l <- ncol(E))
```

## Computation

### From CCA scores

We compute the $H_k(i, j)$ from the LC (for rows = sites) and WA (for columns = species) scores computed with CCA (noted $LC$ and $C$). This formula is a direct extension of formula (11) in @thioulouse1992 but we replace the CA ordination scores with the CCA ordination scores.

In CCA, we have several scores for the sites. The notation $LC_k(i)$ represents the LC scores (or the `li` of ade4). The $C_k(j)$ are the species scores `co`.

$$
H_k(i, j) = \frac{LC_k(i) + C_k(j)}{\sqrt{2 \lambda_k \mu_k}}
$$

```{r}
Ydf <- as.data.frame(Y)
ca <- dudi.coa(Ydf, 
               scannf = FALSE,
               nf = min(r - 1, c - 1))

neig <- min(c(r-1, c, l))
cca <- pcaiv(dudi = ca, 
             df = E,
             scannf = FALSE,
             nf = neig)

L_CCA <- cca$li
C_CCA <- cca$co

lambda_CCA <- cca$eig
mu_CCA <- 1 + sqrt(lambda_CCA)
```

We also compute reciprocal scaling for comparison (to check results, not shown):

```{r}
rec_cca <- reciprocal.caiv(cca)
```

```{r}
# Transform matrix to count table
Yfreq <- as.data.frame(as.table(Y))
colnames(Yfreq) <- c("row", "col", "Freq")

# Remove the cells with no observation
Yfreq0 <- Yfreq[-which(Yfreq$Freq == 0),]
Yfreq0$colind <- match(Yfreq0$col, colnames(Y)) # match index and species names


# Initialize results matrix
H <- matrix(nrow = nrow(Yfreq0), 
            ncol = length(lambda_CCA))

for (k in 1:length(lambda_CCA)) { # For each axis
  ind <- 1 # initialize row index
  for (obs in 1:nrow(Yfreq0)) { # For each observation
    i <- Yfreq0$row[obs]
    j <- Yfreq0$col[obs]
    H[ind, k] <- (L_CCA[i, k] + C_CCA[j, k])/sqrt(2*lambda_CCA[k]*mu_CCA[k])
    ind <- ind + 1
  }
}
```

```{r, include = FALSE}
# Check result
rec_cca[,1:neig]/H
```

### From canonical correlation analysis

To perform the canonical correlation analysis, we compute the inflated tables $R$ ($\omega \times l$) and $C$ ($\omega \times c$) from $Y$ ($r \times c$) and $E$ ($r \times l$). The difference with CA is that we use $E$ instead of $Y$ to compute the inflated table $R$. $R$ is equivalent to $E$ where rows of $E$ are duplicated as many times as there are correspondences in $Y$.

We take the frequency table defined before and use it to compute the inflated tables (with weights):

```{r}
# Create indicator tables
tabR <- acm.disjonctif(as.data.frame(Yfreq0$row))
tabR <- as.matrix(tabR) %*% as.matrix(E) # duplicate rows of E according th the correspondences of Y
tabC <- acm.disjonctif(as.data.frame(Yfreq0$col))
colnames(tabC) <- colnames(Y)

# Get weights
wt <- Yfreq0$Freq
```

Below are the first lines of tables $R$ and $C$:

```{r, echo=FALSE}
knitr::kable(head(tabR, 30))
knitr::kable(head(tabC, 30))
```

Then, we perform a canonical correlation on the scaled tables $R_{scaled}$ and $C_{scaled}$. We find the coefficients $\rho$ and $\gamma$ maximizing the correlation between the scores $S_R = R_{scaled} \rho$ and $S_C = C_{scaled} \gamma$.

```{r}
# Center tables
tabR_scaled <- scalewt(tabR, wt, 
                       scale = FALSE)
tabC_scaled <- scalewt(tabC, wt, 
                       scale = FALSE)

res <- cancor(diag(sqrt(wt)) %*% tabR_scaled, 
              diag(sqrt(wt)) %*% tabC_scaled, 
              xcenter = FALSE, ycenter = FALSE)
# res gives the coefficients of the linear combinations that maximizes the correlation between the 2 dimensions
dim(res$xcoef) # l columns -> R_scaled is of full rank
dim(res$ycoef) # c-1 columns -> C_scaled is not of full rank

# Compute these scores from this coef
scoreR <- tabR_scaled[, 1:l]  %*% res$xcoef
scoreC <- tabC_scaled[, 1:(c-1)]  %*% res$ycoef
```

We have $H = (S_R + S_C)_{scaled}$.

```{r}
# Get H
scoreRC <- scoreR[, 1:l] + scoreC[, 1:l] # here l < c-1 so l axes
scoreRC_scaled <- scalewt(scoreRC, wt = wt)
```

```{r}
# Check result
all(abs(scoreRC_scaled/H) - 1 < 10e-10)
```

### Plot RC scores

```{r, warning=FALSE, fig.width=5, fig.height=4}
#| code-fold: true
multiplot(indiv_row = H, 
          indiv_row_lab = paste0("site ", Yfreq0$row, "/", Yfreq0$col),
          row_color = "black", eig = lambda_CCA)
```

## Conditional means and variances from RC scores


::: {.callout-tip title="*TL;DR*"}
Once we have the correspondences scores, we can group them by row (site) or column (species) to compute conditional summary statistics:

-   conditional mean for site $i$ or species $j$ (for each axis $k$)
-   conditional variance for site $i$ or species $j$ (for each axis $k$)
-   conditional covariance for site $i$ or species $j$ (between axes $k$ and $l$)

These conditional statistics can be computed using $H_k(i,j)$ or using the CA scores:

**Formulas using** $H_k(i,j)$

The means and variances are simply the weighted means/variances of the $H_k(i, j)$ for a fixed $i$ or $j$.


|                   | Rows (sites)  | Columns (species)                                                                           |
|-------------------|------------------------------|------------------------|
| Mean for axis $k$                | $$m_k(i) = \frac{1}{y_{i\cdot}} \sum_{j = 1}^c y_{ij} H_k(i,j)$$                           | $$m_k(j) = \frac{1}{y_{\cdot j}} \sum_{i = 1}^r y_{ij} H_k(i,j)$$                           |
| Variance for axis $k$            | $$s_k^2(i) = \frac{1}{y_{i\cdot}} \sum_{j = 1}^c y_{ij} \left(H_k(i,j) - m_k(i)\right)^2$$ | $$s_k^2(j) = \frac{1}{y_{\cdot j}} \sum_{i = 1}^r y_{ij} \left(H_k(i,j) - m_k(j)\right)^2$$ |
| Covariance between axes $k$, $l$ | $$c_{kl}(i) = \frac{1}{y_{i \cdot}}\sum_{j=1}^c y_{ij}H_k(i, j)H_l(i, j) - m_k(i)m_l(i)$$  | $$c_{kl}(j) = \frac{1}{y_{\cdot j}}\sum_{i=1}^r y_{ij}H_k(i, j)H_l(i, j) - m_k(j)m_l(j)$$   |

**Formulas using CA scores**

***Note that the LC score (notation: $LC$) is used for the species variance and the WA score (notation: $L$) for the sites variance.***

|                       | Rows (sites)                 | Columns (species)      |
|-----------------------|------------------------------|------------------------|
| Mean for axis $k$     | $$m_k(i) =  \frac{1}{\sqrt{2 \mu_k}} \times (LC1_k(i) + L_k(i))$$ | $$m_k(j) = \frac{\sqrt{\mu_k}}{\sqrt{2\lambda_k}} C_k(j)$$ |
| Variance for axis $k$ | $$s^2_k(i) = \frac{1}{2\lambda_k\mu_k} \left( \frac{1}{y_{i \cdot}} \sum_{j = 1}^c \left(y_{ij} C_k^2(j) \right) - \lambda_k L_k^2(i) \right)$$ | $$s^2_k(j) = \frac{1}{2\lambda_k\mu_k} \left( \frac{1}{y_{\cdot j}} \sum_{i = 1}^r \left(y_{ij} LC_k^2(i) \right) - \lambda_k C_k^2(j) \right)$$                                             |
| Covariance between axes $k$, $l$ |  |  |
:::

Let's start from the means/variances computed from the RC scores ($H$).

```{r}
fac <- sqrt(mu_CCA)/sqrt(2*lambda_CCA)
n <- sum(Y)
```

### For rows = sites

Below is a graphical illustration of scoreRC grouped by rows:

```{r}
s.class(scoreRC,
        wt = Yfreq0$Freq,
        fac = as.factor(Yfreq0$row),
        plabels.col = params$colsite, 
        main = "With RC score (points = correspondences)")
```

We compute the groupwise mean and variance.

```{r}
# With scaled values
mrowsRC <- meanfacwt(scoreRC_scaled, fac = Yfreq0$row, wt = Yfreq0$Freq)
mrowsRC/(as.matrix(cca$l1 + cca$ls) %*% diag(1/sqrt(2*mu_CCA)))
```

```{r}
# With non-scaled values
mrowsRC_ns <- meanfacwt(scoreRC, fac = Yfreq0$row, wt = Yfreq0$Freq)
mrowsRC_ns/((cca$l1 + cca$ls)*1/sqrt(n))
```

Variances

```{r}
# With scaled values
varrowsRC <- varfacwt(scoreRC_scaled, fac = Yfreq0$row, wt = Yfreq0$Freq)

# With non-scaled values
varrowsRC_ns <- varfacwt(scoreRC, fac = Yfreq0$row, wt = Yfreq0$Freq)
```


So we know that the variances per site of the scoreC (scoreC = `c1` $\times \frac{1}{\sqrt{n}}$) is equal to the non-scaled variance of the RC scores. The mean per site of the scoreC is `ls` (WA score) $\times \frac{1}{\sqrt{n}}$.

```{r}
# Get marginal counts
yi_ <- rowSums(Y)
y_j <- colSums(Y)

varrowsCCA <- matrix(nrow = r, 
                     ncol = l)

for (i in 1:r) {
  # Get CCA scores for site i
  Li <- cca$ls[i, ]
  
  # Compute the part with the sum on Cj
  # we add all coordinates Cj^2 weighted by the number of observations on site i
  sumCj <- t(Y[i, ]) %*% as.matrix(cca$co)^2

  # Fill i-th row with site i variance along each axis
  varrowsCCA[i, ] <- (1/(2*lambda_CCA*mu_CCA)) * (((1/yi_[i])*sumCj) - lambda_CCA*as.numeric(Li)^2)
}
```

```{r}
varrowsRC/varrowsCCA
```


```{r, include=FALSE}
# We can also check the non-scaled RC value
varrowsRC_ns/(varrowsCCA %*% diag(2*mu_CCA/n))
```


### For columns = species

Below is an illustration of the RC scores grouped by species.

```{r}
s.class(scoreRC,
        wt = Yfreq0$Freq,
        fac = as.factor(Yfreq0$colind),
        lab = colnames(Y),
        plabels.col = params$colspp, 
        main = "With RC score (points = correspondences)")
```

```{r}
mcolsRC <- meanfacwt(scoreRC_scaled, fac = Yfreq0$colind, wt = Yfreq0$Freq)

mcolsRC/(as.matrix(cca$co) %*% diag(fac))
```

```{r}
mcolsRC_ns <- meanfacwt(scoreRC, fac = Yfreq0$colind, wt = Yfreq0$Freq)

mcolsRC_ns/cca$co
```

```{r}
# With scaled values
varcolsRC <- varfacwt(scoreRC_scaled, fac = Yfreq0$colind, wt = Yfreq0$Freq)

# With non-scaled values
varcolsRC_ns <- varfacwt(scoreRC, fac = Yfreq0$colind, wt = Yfreq0$Freq)
```


So we know that the variances per species of the scoreR (scoreR = `l1` $\times \frac{1}{\sqrt{n}}$) is equal to the non-scaled variance of the RC scores. The mean per species of the scoreR is `co` $\times \frac{1}{\sqrt{n}}$.

```{r}
varcolsCCA <- matrix(nrow = c, 
                     ncol = l)

for (j in 1:c) {
  # Get CCA scores for species j
  Cj <- cca$co[j, ]
  
  # Compute the part with the sum on Li
  # we add all coordinates Li^2 weighted by the number of observations on species j
  sumLi <- t(Y[, j]) %*% as.matrix(cca$li)^2

  # Fill i-th row with site i variance along each axis
  varcolsCCA[j, ] <- (1/(2*lambda_CCA*mu_CCA)) * (((1/y_j[j])*sumLi) - lambda_CCA*as.numeric(Cj)^2)
}
```

```{r}
varcolsRC/varcolsCCA

varcolsRC_ns/(varcolsCCA %*% diag(2*mu_CCA/n))
```


# BEFORE

## Conditional means and variances

::: {.callout-tip title="*TL;DR*"}
|                | Mean per species                                         | Mean per site                                       |
|----------------|--------------------------------------|------------------|
| ScoreR         | Species score (`$co`) $\times \frac{1}{\sqrt{n}}$        | Normed LC score (`$l1`) $\times \frac{1}{\sqrt{n}}$ |
| ScoreC         | Normed species score (`$c1`) $\times \frac{1}{\sqrt{n}}$ | WA score (`$ls`) $\times \frac{1}{\sqrt{n}}$        |
| scoreRC        | `$co` $\times \alpha_k$ (unknown)                        | (`$l1` + `$ls`) $\times \frac{1}{\sqrt{n}}$         |
| scoreRC scaled | `$co` $\times \frac{\sqrt{\mu}}{\sqrt{2\lambda}}$        | (`$l1` + `$ls`) $\times \beta_k$ (unknown)          |

|                | Variances per species              | Variances per site                 |
|----------------|------------------------------------|------------------------------------|
| ScoreR         | $s^2_k(j) \times \frac{2\mu_k}{n}$ | None                               |
| ScoreC         | None                               | $s^2_k(i) \times \frac{2\mu_k}{n}$ |
| scoreRC        | $s^2_k(j) \times \frac{2\mu_k}{n}$ | $s^2_k(i) \times \frac{2\mu_k}{n}$ |
| scoreRC scaled | $$s^2_k(j) = \frac{1}{2 \lambda_k \mu_k} \left( \frac{1}{y_{\cdot} j} \sum_{i = 1}^r \left(y_{ij} L_k^2(i) \right) - C_k^2(i) \right)$$ ($L$ = sites `li` (LC scores) and $C$ = species `co`) | $$s^2_k(i) = \frac{1}{2 \lambda_k \mu_k} \left( \frac{1}{y_{i \cdot}} \sum_{j = 1}^c \left(y_{ij} C_k^2(j) \right) - \lambda_k LS_k^2(i) \right)$$ ($C$ = species `co` and $LS$ = sites `ls` (WA scores))  |
:::

Let's compare the means obtained from canonical correlations scores (RC scores, R scores or C scores) to the CCA scores.



#### For rows = sites (group per row)


##### scoreC

Below is a graphical illustration of scoreC grouped by rows:

```{r}
s.class(scoreC,
        wt = Yfreq0$Freq,
        fac = as.factor(Yfreq0$row),
        ppoints.col = params$colspp,
        plabels.col = params$colsite, 
        main = "With C score (points = species scores)")
```

We compute the following mean: $m(\text{scoreC})_k(i) = \frac{1}{y_{i\cdot}} \sum_{j = 1}^c y_{ij} \text{scoreC}_k(i,j)$. To compute these conditional means, we use the `meanfacwt` function from the `ade4` package.

We group column scores (scoreC) by row:

```{r}
mrowsC <- meanfacwt(scoreC, fac = Yfreq0$row, wt = Yfreq0$Freq)

mrowsC/(cca$ls * 1/sqrt(n))
```

This corresponds to the `$ls` score of the CCA (ie the WA score for sites).

Now let's compute the variance of scoreC per row:

```{r}
varrowsC <- varfacwt(scoreC, fac = Yfreq0$row, wt = Yfreq0$Freq)
```

```{r}
varrowsC[, 1:ncol(varrowsRC)]/varrowsRC

varrowsC[, 1:ncol(varrowsRC)]/varrowsRC_ns
```

```{r}
varrowsC[, 1:ncol(varrowsRC)]/(varrowsCCA %*% diag(2*mu_CCA/n))
```


##### scoreR

Now, we compute the mean per **row** (site) from the **row** (sites) scores.

Below is a graphical illustration of scoreR grouped by rows:

```{r}
s.class(scoreR,
        wt = Yfreq0$Freq,
        fac = as.factor(Yfreq0$row),
        ppoints.col = params$colsite,
        plabels.col = params$colsite, 
        main = "With R score (points = sites scores)")
```

All points of the same site ares superimposed.

```{r}
mrowsR <- meanfacwt(scoreR, fac = Yfreq0$row, wt = Yfreq0$Freq)

mrowsR*sqrt(n)/cca$l1
```

The variance is null.

### For columns = species (group per column)


##### scoreC

We group the scoreC per species. Below is an illustration:

```{r}
s.class(scoreC,
        wt = Yfreq0$Freq,
        fac = as.factor(Yfreq0$colind),
        lab = colnames(Y),
        ppoints.col = params$colspp,
        plabels.col = params$colspp, 
        main = "With C score (points = species scores)")
```

```{r}
mcolsC <- meanfacwt(scoreC, fac = Yfreq0$colind, wt = Yfreq0$Freq)

mcolsC * sqrt(n)/cca$c1
```

The variance is null.

##### scoreR

Below are the scoreR grouped by column:

```{r}
s.class(scoreR,
        wt = Yfreq0$Freq,
        fac = as.factor(Yfreq0$colind),
        lab = colnames(Y),
        ppoints.col = params$colsite,
        plabels.col = params$colspp, 
        main = "With R score (points = sites scores)")
```

```{r}
mcolsR <- meanfacwt(scoreR, fac = Yfreq0$colind, wt = Yfreq0$Freq)

# Colinearity but different factor
mcolsR * sqrt(n)/cca$co
```

```{r}
varcolsR <- varfacwt(scoreR, fac = Yfreq0$colind, wt = Yfreq0$Freq)

varcolsR/varcolsRC_ns
```

```{r}
varcolsR/(varcolsCCA %*% diag(2*mu_CCA/n))

```

### Test to get variance for sites LC scores

We want to add ellipses for sites on this plot:

```{r}
#| code-fold: true
s.label(cca$c1,
        plabels.col = params$colspp)
s.label(cca$li, 
        plabels.col = params$colsite,
        add = TRUE)
```

To do that it seems logical to link sites (`li`) with species present in these sites (`c1`) to get ellipses.

We know that the means of `scoreR` are equal to `l1` (LC score):

```{r, include=FALSE}
#| code-fold: true
s.class(scoreR*sqrt(n), 
        wt = Yfreq0$Freq,
        fac = as.factor(Yfreq0$row),
        ppoints.col = params$colsite,
        plabels.col = params$colsite)
s.label(cca$l1,
        plabels.col = "red",
        add = TRUE)

s.label(mrowsR,
        plabels.col = params$colsite)
s.label(cca$l1,
        plabels.col = "red",
        add = TRUE)
```

But we want the `$li` so we multiply by $\sqrt{\lambda}$:

```{r, include=FALSE}
#| code-fold: true
s.class(as.matrix(scoreR*sqrt(n)) %*% diag(sqrt(lambda_CCA)), 
        wt = Yfreq0$Freq,
        fac = as.factor(Yfreq0$row),
        ppoints.col = params$colsite,
        plabels.col = params$colsite)
s.label(cca$li,
        plabels.col = "red",
        add = TRUE)
```

We also know that the `$c1` scores can be obtained from the mean C scores:

```{r, include=FALSE}
#| code-fold: true
s.class(scoreC*sqrt(n),
        fac = as.factor(Yfreq0$colind), 
        wt = Yfreq0$Freq,
        labels = colnames(Y),
        plabels.col = params$colspp)
s.label(cca$c1,
        plabels.col = "red",
        add = TRUE)
```

Let's get the mean of the `$c1` scores:

```{r, include=FALSE}
#| code-fold: true

# get the relative abundance in each site
Yrelsite <- sweep(Y, 1, FUN = "/", rowSums(Y))

litest <- as.matrix(Yrelsite) %*% as.matrix(cca$c1)

litest/cca$li


s.label(cca$li, plabels.col = params$colsite)
s.label(litest, add = TRUE, plabels.col = "red")
```

Let's plot site 1 with the mean of its species.

```{r}
#| code-fold: true

# Get species that are present in site 1
sp <- which(Y[1, ] != 0)

# Get $c1 corresponding to those species
c1 <- cca$c1[sp, ]

# Plot the $c1 and the $li of the site
s.class(c1, 
        fac = as.factor(rep(1, nrow(c1))), 
        wt = cca$cw[sp],
        ppoints.col = params$colspp,
        plabels.col = params$colspp)
s.label(cca$li[1, ],
        plabels.col = "red",
        add = TRUE)

# With relative weights
s.class(c1, 
        fac = as.factor(rep(1, nrow(c1))), 
        wt = Yrelsite[1, sp],
        ppoints.col = params$colspp,
        plabels.col = params$colspp)
s.label(cca$li[1, ],
        plabels.col = "red",
        add = TRUE)
```

Conclusion: the `c1` means and the `li` are not the same.

We try something else: we place the `l1` for the sites and compute the species mean positions from the `l1` (species niches as predicted by the sites environmental variables). And we use those species back to compute the `l1` (or rather the `li`), but this time we have a variance.

```{r}
# get the relative abundance in each spp
Yrelspp <- sweep(Y, 2, FUN = "/", colSums(Y))

ctest <- t(Yrelspp) %*% as.matrix(cca$l1)

# It is equal to the $co
ctest/cca$co

# Transform to the c1
c1test <- ctest %*% diag(1/sqrt(lambda_CCA))
c1test/cca$c1

# Compute back the site means from ctest/co
litest <- Yrelsite %*% c1test
litest/cca$li # not equal to li

s.label(cca$li, plabels.col = params$colsite)
s.label(litest, add = TRUE, plabels.col = "red")
```

Let's plot site 1 with the mean of its species.

```{r}
#| code-fold: true

# Get species that are present in site 1
sp <- which(Y[1, ] != 0)

# Get ctest corresponding to those species
c1 <- c1test[sp, ]

# Plot the $c1 and the $li of the site
s.class(c1, 
        fac = as.factor(rep(1, nrow(c1))), 
        wt = cca$cw[sp],
        ppoints.col = params$colspp,
        plabels.col = params$colspp)
s.label(cca$li[1, ],
        plabels.col = "red",
        add = TRUE)
```

This doesn't work either.

```{r}
# We use the coefficients of the columns (species) from the R coefficients 
scoreCtest <- as.matrix(tabC[, 1:l]) %*% res$xcoef

s.label(scoreR)
```

### Plots

From the scores above, we can have a variance for the WA sites scores (`$ls`): from

```{r}
#| code-fold: true
s.label(cca$ls, plabels.col = params$colsite)
```

to

```{r}
#| code-fold: true
s.class(scoreC*sqrt(n), 
        wt = Yfreq0$Freq,
        fac = as.factor(Yfreq0$row),
        ppoints.col = params$colspp,
        plabels.col = params$colsite)

```

There is a parallel with the classical CCA plot `$c1` (species scaled score) /`$ls` (sites WA score) (scaling type 1: preserves species distances)

```{r}
s.label(cca$c1, plabels.col = params$colspp)
s.label(cca$ls, add = TRUE, plabels.col = params$colsite)
```

We can't get a variance for the sites LC scores (`$l1`) because sites correspondences are duplicated.

```{r}
#| code-fold: true
s.label(cca$l1, plabels.col = params$colsite)
```

and

```{r}
#| code-fold: true
s.class(scoreR*sqrt(n), 
        wt = Yfreq0$Freq,
        fac = as.factor(Yfreq0$row),
        ppoints.col = params$colsite,
        plabels.col = params$colsite)
```

are identical.

However we can have a variance for the species scores (`$co`): from

```{r}
#| code-fold: true
s.label(cca$co,
        plabels.col = params$colspp)
```

to

```{r}
#| code-fold: true
s.class(scoreR*sqrt(n), 
        labels = colnames(Y),
        plabels.col = params$colspp,
        ppoints.col = params$colsite,
        wt = Yfreq0$Freq,
        fac = as.factor(Yfreq0$colind))
```

Here, too, there is a parallel with the classical CCA plot `$l1` (sites scaled WA scores) /`$co` (species scores) (scaling type 2: preserves sites distances)

```{r}
s.label(cca$l1, plabels.col = params$colsite)
s.label(cca$co, add = TRUE, plabels.col = params$colspp)
```

We can also use RC scores for species:

```{r}
#| code-fold: true
s.class(scoreRC_scaled, 
        labels = colnames(Y),
        plabels.col = params$colspp,
        wt = Yfreq0$Freq,
        fac = as.factor(Yfreq0$colind))
```

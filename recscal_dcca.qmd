---
title: "Reciprocal scaling with dcCA"
editor: visual
params:
  colsite: "burlywood4"
  colspp: "cornflowerblue"
---

```{r, results='hide', message=FALSE}
#| code-fold: true

# Paths
library(here)

# Multivariate analysis
library(ade4)
library(adegraphics)

# dc-CA
source(here("functions/dpcaiv2-ade4.R"))

# Reciprocal scaling
source(here("functions/reciprocal.R"))

# Matrix algebra
library(expm)

# Plots
source(here("functions/plot.R"))
library(gridExtra)
```

## Introduction

This is an extension of reciprocal scaling defined for correspondence analysis by @thioulouse1992 to double-constrained correspondence analysis.

Here, we have 3 matrices:

-   A data matrix $Y$ ($r \times c$)
-   A matrix of predictor variables $E$ ($r \times l$)
-   A matrix of predictor variables $T$ ($c \times k$)

```{r, echo=FALSE}
dat <- readRDS(here("data/Barbaro2012.rds"))

Y <- dat$comm
E <- dat$envir
T_ <- dat$traits

r <- dim(Y)[1]
c <- dim(Y)[2]
l <- ncol(E)
k <- ncol(T_)

plotmat(r = r, c = c, l = l, k = k,
        T_ = TRUE,
        E = TRUE)
```

```{r}
(r <- dim(Y)[1])
(c <- dim(Y)[2])
(l <- ncol(E))
(k <- ncol(T_))
```

## Computation

### From dcCA scores

We compute the $H^{dcCA}_k(i, j)$ from the LC scores computed with CCA (noted $L^{dcCA}$ and $C^{dcCA}$). This formula is a direct extension of formula (11) in @thioulouse1992 but we replace the ordination scores obtained with CA with the ordination scores obtained with dcCA.

$$
H_k^{dcCA}(i, j) = \frac{L^{dcCA}_k(i) + C^{dcCA}_k(j)}{\sqrt{2 \lambda_k \mu_k}}
$$

```{r}
Ydf <- as.data.frame(Y)
ca <- dudi.coa(Ydf, 
               scannf = FALSE,
               nf = min(r - 1, c - 1))

neig <- min(c(k, l))
dcca <- dpcaiv2(dudi = ca, 
                dfR = E,
                dfQ = T_,
                scannf = FALSE, 
                nf = neig)

L_dcca <- dcca$li
C_dcca <- dcca$co

lambda_dcca <- dcca$eig
mu_dcca <- 1 + sqrt(lambda_dcca)
```

We also compute reciprocal scaling for comparison:

```{r}
rec_dcca <- reciprocal.dpcaiv(dcca)
```

```{r}
# Transform matrix to count table
Yfreq <- as.data.frame(as.table(Y))
colnames(Yfreq) <- c("row", "col", "Freq")

# Remove the cells with no observation
Yfreq0 <- Yfreq[-which(Yfreq$Freq == 0),]
Yfreq0$colind <- match(Yfreq0$col, colnames(Y)) # match index and species names


# Initialize results matrix
H_dcca <- matrix(nrow = nrow(Yfreq0), 
                 ncol = length(lambda_dcca))

for (kl in 1:length(lambda_dcca)) { # For each axis
  ind <- 1 # initialize row index
  for (obs in 1:nrow(Yfreq0)) { # For each observation
    i <- Yfreq0$row[obs]
    j <- Yfreq0$col[obs]
    H_dcca[ind, kl] <- (L_dcca[i, kl] + C_dcca[j, kl])/sqrt(2*lambda_dcca[kl]*mu_dcca[kl])
    ind <- ind + 1
  }
}
```

```{r, include = FALSE}
# Check result
rec_dcca[,1:neig]/H_dcca
```

### From canonical correlation analysis

To perform the cancor, we compute the inflated tables $R$ ($\omega \times l$) and $C$ ($\omega \times k$) from $E$ ($r \times l$) and $T$ ($r \times k$). $R$ and $C$ are respectively equivalents to $E$ and $T$ where rows of are duplicated as many times as there are correspondences in $Y$.

We take the frequency table defined before and use it to compute the inflated tables (with weights):

```{r}
# Create indicator tables
tabR <- acm.disjonctif(as.data.frame(Yfreq0$row))
tabR <- as.matrix(tabR) %*% as.matrix(E)
tabC <- acm.disjonctif(as.data.frame(Yfreq0$col))
tabC <- as.matrix(tabC) %*% as.matrix(T_)

# Get weights
wt <- Yfreq0$Freq
```

Below are the first lines of tables $R$ and $C$:

```{r, echo=FALSE}
knitr::kable(head(tabR, 30))
knitr::kable(head(tabC, 30))
```

Then, we perform a canonical correlation on the scaled tables $R_{scaled}$ and $C_{scaled}$. We find the coefficients $\rho$ and $\gamma$ maximizing the correlation between the scores $S_R = R_{scaled} \rho$ and $S_C = C_{scaled} \gamma$.

```{r}
# Center tables
tabR_scaled <- scalewt(tabR, wt, 
                       scale = FALSE)
tabC_scaled <- scalewt(tabC, wt, 
                       scale = FALSE)

res <- cancor(diag(sqrt(wt)) %*% tabR_scaled, 
              diag(sqrt(wt)) %*% tabC_scaled, 
              xcenter = FALSE, ycenter = FALSE)
# res gives the coefficients of the linear combinations that maximizes the correlation between the 2 dimensions
dim(res$xcoef) # l columns -> R_scaled is of full rank
dim(res$ycoef) # k columns -> C_scaled is of full rank

# Compute these scores from this coef
scoreR <- tabR_scaled[, 1:l]  %*% res$xcoef
scoreC <- tabC_scaled[, 1:k]  %*% res$ycoef
```

We have $H = (S_R + S_C)_{scaled}$.

```{r}
# Get H
scoreRC <- scoreR[, 1:l] + scoreC[, 1:l] # here we have l < k so l axes
scoreRC_scaled <- scalewt(scoreRC, wt = wt)
```

```{r, include=FALSE}
# Check result
all(abs(scoreRC_scaled/H_dcca) - 1 < 10e-10)
```

### Plot

```{r, warning=FALSE}
#| code-fold: true
multiplot(indiv_row = H_dcca, 
          indiv_row_lab = paste0("site ", Yfreq0$row, "/", Yfreq0$col),
          row_color = "black", eig = lambda_dcca)
```

## Conditional means and variances


::: {.callout-tip title="*TL;DR*"}
|                      | Mean per species                              | Mean per site                                       |
|----------------------|-----------------------------------------------|-----------------------------------------------------|
| ScoreR               | WA score (`$lsQ`) $\times \frac{1}{\sqrt{n}}$ | Normed LC score (`$l1`) $\times \frac{1}{\sqrt{n}}$ |
| ScoreC               | Normed LC score (`$c1`) $\times \frac{1}{\sqrt{n}}$ | WA score (`$lsR`) $\times \frac{1}{\sqrt{n}}$ |
| scoreRC (not scaled) | (`$c1` + `$lsQ`) $\times \frac{1}{\sqrt{n}}$  | `$l1` + `$lsR` ($\times \frac{1}{\sqrt{n}}$)  |
:::


Let's compare the means obtained from canonical correlations scores and the dcCA scores.

### For rows = sites

```{r, include=FALSE}
fac <- sqrt(mu_dcca)/sqrt(2*lambda_dcca)
```

```{r}
n <- sum(Y)
```

We compute the mean per **row** (site) from:

-   the **row** (sites) scores

```{r}
mrowsR <- meanfacwt(scoreR, fac = Yfreq0$row, wt = Yfreq0$Freq)

mrowsR*sqrt(n)/dcca$l1
```

-   the **column** (species) scores

```{r}
mrowsC <- meanfacwt(scoreC, fac = Yfreq0$row, wt = Yfreq0$Freq)

mrowsC*sqrt(n)/dcca$lsR
```

-   the mixed (RC) scores

```{r}
mrowsRC <- meanfacwt(scoreRC_scaled, fac = Yfreq0$row, wt = Yfreq0$Freq)
mrowsRC/(dcca$lsR + dcca$l1)
```

```{r}
mrowsRC_ns <- meanfacwt(scoreRC, fac = Yfreq0$row, wt = Yfreq0$Freq)
mrowsRC_ns*sqrt(n)/(dcca$lsR + dcca$l1)
```

### For columns = species


We compute the mean per **column** (species) from:

-   the **row** (sites) scores

```{r}
mcolsR <- meanfacwt(scoreR, fac = Yfreq0$colind, wt = Yfreq0$Freq)

mcolsR * sqrt(n)/dcca$lsQ
```

-   the **column** (species) scores

```{r}
mcolsC <- meanfacwt(scoreC, fac = Yfreq0$colind, wt = Yfreq0$Freq)

mcolsC * sqrt(n)/dcca$c1
```

-   the mixed (RC) scores
```{r}
mcolsRC <- meanfacwt(scoreRC_scaled, fac = Yfreq0$colind, wt = Yfreq0$Freq)

mcolsRC * sqrt(n)/(as.matrix(dcca$c1 + dcca$lsQ) %*% diag(fac))
```

```{r}
mcolsRC_ns <- meanfacwt(scoreRC, fac = Yfreq0$colind, wt = Yfreq0$Freq)

mcolsRC_ns * sqrt(n)/(dcca$c1 + dcca$lsQ)
```


### Plots

From the scores above, we can have a variance for the WA sites scores (`$lsR`): from

```{r}
#| code-fold: true
s.label(dcca$lsR, plabels.col = params$colsite)
```

to

```{r}
#| code-fold: true
s.class(scoreC*sqrt(n), 
        wt = Yfreq0$Freq,
        fac = as.factor(Yfreq0$row),
        ppoints.col = params$colspp,
        plabels.col = params$colsite)
```

There is a parallel with the classical dcCA plot `$c1` (species LC score) /`$lsR` (sites WA score) (scaling type 1: preserves species distances)

```{r}
s.label(dcca$c1, plabels.col = params$colspp)
s.label(dcca$lsR, add = TRUE, plabels.col = params$colsite)
```

The RC scores have no direct equivalent, sadly:

```{r}
#| code-fold: true
s.class(scoreRC*sqrt(n), 
        wt = Yfreq0$Freq,
        fac = as.factor(Yfreq0$row),
        ppoints.col = params$colspp,
        plabels.col = params$colsite)
```


```{r}
#| code-fold: true

# Create a long df with $lsR and $l1
bindlsR <- dcca$lsR
colnames(bindlsR) <- colnames(dcca$l1)
lscores <- rbind(dcca$l1, bindlsR)
# Invert first column
mrowsRC_ns_inv <- mrowsRC_ns
mrowsRC_ns_inv[, 1] <- -mrowsRC_ns_inv[, 1]
```

RC scores means by row (site) are equal to `$lsR`+`$l1` (surimposed on this graph:)

```{r}
#| code-fold: true

# What is exactly superposed to RC scores is $lsR+$l1
s.label((dcca$lsR+dcca$l1), 
        plabels.col = params$colsite)
s.label(mrowsRC_ns_inv*sqrt(n),
        add = TRUE)
# mrowsRC_ns_inv*sqrt(n)/(dcca$l1+dcca$lsR)
```


However, perhaps it is more intuitive to see RC scores as the mean between `$lsR` and `$l1`: for that, we divide RC scores by 2 (shown surimposed to the mean between `$lsR` and `$l1` on the graph below)

```{r}
#| code-fold: true

# What is more intuitive is to superpose RC scores/2 to the centroid if lsQ and l1 scores 
s.class(lscores,
        fac = as.factor(rep(rownames(Y), 2)),
        ppoints.col = params$colsite,
        wt = rep(dcca$lw, 2),
        plabels.col = params$colsite)
s.label(mrowsRC_ns_inv*sqrt(n)/2,
        add = TRUE)
```
We can't get a variance for the sites LC scores (`$l1`) because sites correspondences are duplicated.

```{r}
#| code-fold: true
s.label(dcca$l1, 
        plabels.col = params$colsite)
```

and

```{r}
#| code-fold: true
s.class(scoreR*sqrt(n), 
        wt = Yfreq0$Freq,
        fac = as.factor(Yfreq0$row),
        ppoints.col = params$colsite,
        plabels.col = params$colsite)
```

are identical.

However we can have a variance for the species WA scores (`$lsQ`): from

```{r}
#| code-fold: true
s.label(dcca$lsQ,
        plabels.col = params$colspp)
```

to

```{r}
#| code-fold: true
s.class(scoreR*sqrt(n), 
        labels = colnames(Y),
        plabels.col = params$colspp,
        ppoints.col = params$colsite,
        wt = Yfreq0$Freq,
        fac = as.factor(Yfreq0$colind))
```

Here too there is a parallel with the "classical" dcCA plot: `$l1` (sites LC score) /`$lsQ` (species WA score) (scaling type 2: preserves species distances)

```{r}
s.label(dcca$l1, plabels.col = params$colsite)
s.label(dcca$lsQ, add = TRUE, plabels.col = params$colspp)
```

But we can't get a variance for species LC scores (`$c1`):

```{r}
#| code-fold: true
s.label(dcca$c1,
        plabels.col = params$colspp)
```

and

```{r}
#| code-fold: true
s.class(scoreC*sqrt(n), 
        labels = colnames(Y),
        plabels.col = params$colspp,
        ppoints.col = params$colsite,
        wt = Yfreq0$Freq,
        fac = as.factor(Yfreq0$colind))
```

are identical.